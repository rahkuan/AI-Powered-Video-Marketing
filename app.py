# app.py

import hashlib
import os
from flask import Flask, request, jsonify, send_from_directory, send_file, abort
from flask_restful import Api, Resource
from enhance_image import enhance_image  # Import the function from enhance_image.py
from generate_style_image import generate_image  # Import the function from the new module
from generate_motion import image_to_video
from audio_generator import generate_voiceover, generate_music, convert_gif_to_mp4, enhance_video_with_audio 

STOCK_IMAGES_DIR = os.path.join(os.getcwd(), 'static', 'stock_images')

app = Flask(__name__, static_folder='static')
api = Api(app)

# Variable to store the uploaded image path
uploaded_image_path = "uploaded_image.png"
generated_images_dir = "./generated_images"  # Directory where generated images are saved
generated_videos_dir = "./generated_videos"  # Directory where generated videos are saved

class ImageUpload(Resource):
    def post(self):
        global uploaded_image_path
        # Check if the image is part of the request
        if 'image' not in request.files:
            return {'message': 'No image file provided'}, 400

        file = request.files['image']
        enhance = request.form.get('enhance', 'false').lower() == 'true'  # Check if enhance is true
        if file.filename == '':
            return {'message': 'No selected file'}, 400
        
        # Save the uploaded image
        uploaded_image_path = os.path.join(os.getcwd(), uploaded_image_path)
        file.save(uploaded_image_path)

        # Check if enhancement is needed and handle accordingly
        if enhance:
            enhanced_image_path = enhance_image(uploaded_image_path)  # Get the path of the enhanced image
            return {
                'message': 'Image uploaded and enhanced successfully',
                'enhanced_image_path': enhanced_image_path
            }, 200
        else:
            return {'message': 'Image uploaded successfully without enhancement'}, 200

class GenerateStyleImage(Resource):
    def post(self):
        data = request.get_json()
        prompt = data.get('prompt', '')

        if not prompt:
            return {'message': 'No prompt provided'}, 400
        
        # Create a truncated hash for filename
        prompt_hash = hashlib.md5(prompt.encode()).hexdigest()[:8]
        filename = f"style_image_{prompt_hash}.png"
        #output_path = generate_image(prompt, output_dir=generated_images_dir, filename=filename)

        return {
            'message': 'Image generated successfully',
            'image_file_name': filename  # Assuming images are saved in accessible static directory
        }, 200

class CheckImageAvailability(Resource):
    def get(self):
        image_file_name = request.args.get('image_file_name', '')
        image_path = os.path.join(generated_images_dir, image_file_name)
        
        # Check if the image exists on the server
        if os.path.exists(image_path):
            return {'available': True}, 200
        else:
            return {'available': False}, 404

class GetGeneratedImage(Resource):
    def get(self, image_name):
        image_path = os.path.join(generated_images_dir, image_name)

        # Check if the image file exists and serve it
        if os.path.exists(image_path):
            return send_file(image_path, mimetype='image/png')
        else:
            abort(404, description="Image not found")

class CreateVideo(Resource):
    def post(self):
        data = request.get_json()
        prompt = data.get('prompt', None)
        image_name = data.get('image_name', None)

        # Validate input
        if not prompt and not image_name:
            return {'message': 'No valid input provided. Please enter a prompt or select an image.'}, 400

        try:
            # If a text prompt is provided, generate a video from the style generated by the prompt
            if prompt:
                prompt_hash = hashlib.md5(prompt.encode()).hexdigest()[:8]
                style_image_filename = f"style_image_{prompt_hash}.png"
                style_image_path = os.path.join(generated_images_dir, style_image_filename)

                if not os.path.exists(style_image_path):
                    # return {'message': 'Style image not found. Please generate it first.'}, 404
                    pass
                
                image = './uploaded_image.png'
                video_path = image_to_video(image=image, prompt=prompt, save_dir=generated_videos_dir)
                return {'message': f'Video created successfully at {video_path}'}, 200

            # If an image name is provided, generate a video directly from the selected image
            elif image_name:
                image_path = os.path.join("static/stock_images", image_name)

                if not os.path.exists(image_path):
                    return {'message': 'Selected image not found.'}, 404
                
                image = ['./upload_image.png', image_path] # product image and style image
                video_path = image_to_video(image=image, prompt='', save_dir=generated_videos_dir)
                return {'message': f'Video created successfully at {video_path}'}, 200

        except Exception as e:
            return {'message': f'Error creating video: {str(e)}'}, 500

@app.route('/')
def index():
    return send_from_directory(app.static_folder, 'index.html')

@app.route('/get-stock-images', methods=['GET'])
def get_stock_images():
    # Example images; replace with dynamic fetching or database references as needed
    images = [
        "style-anime.jpg",
        "style-3D.jpg",
        "style-cinematic.jpg",
        "style-painting.jpg"
    ]
    return jsonify(images)

@app.route('/enhance-video', methods=['POST'])
def enhance_video_endpoint():
    """
    Endpoint to enhance a video by generating voiceover audio and background music.

    Expects:
    - 'voiceover_text': Text input for generating voiceover audio.
    - 'music_type': The selected music style/category.
    """
    try:
        # Extract text and music type from the request
        data = request.get_json()
        voiceover_text = data.get('voiceover_text', '')
        music_type = data.get('music_type', 'ambient')

        # Generate the voiceover audio file from the text
        voiceover_path = generate_voiceover(voiceover_text)

        # Generate background music based on the selected music type
        music_path = generate_music(style=music_type, duration=10)
        
        # Replace with video path
        input_gif_path = './generated_videos/output-upscaled-with-prompt.gif'
        
        # Convert .gif animation to .mp4 video
        output_mp4_path = convert_gif_to_mp4(input_gif_path)

        # Enhance a sample video with the generated voiceover and music
        sample_video_path = output_mp4_path
        enhanced_video_path = enhance_video_with_audio(sample_video_path, voiceover_path, music_path, voiceover_gain=0, music_gain=2) # increase volumne of voiceover with positive value of voiceover_gain and decrease with negative value
        print(f"Enhanced video created: {enhanced_video_path}")

        if enhanced_video_path:
            return send_file(enhanced_video_path, as_attachment=True)
        else:
            return jsonify({"error": "Failed to enhance video."}), 500

    except Exception as e:
        return jsonify({"error": str(e)}), 500 

@app.route('/recommend', methods=['POST'])
def recommend():
    """
    Endpoint to handle recommendations based on tags, and recommend voiceover and music background.
    
    Expects JSON body with:
    - 'tags': list of tags
    - 'is_recommend_voiceover': boolean indicating whether to recommend voiceover
    - 'is_recommend_music': boolean indicating whether to recommend music background
    """
    try:
        from personalized_content_generator import build_context_data, get_personalized_voiceover_text, get_personalized_music_type
        data = request.get_json()

        # Extract the data from the request
        tags = data.get('tags', [])
        is_recommend_voiceover = data.get('is_recommend_voiceover', False)
        is_recommend_music = data.get('is_recommend_music', False)
        product_description = data.get('product_description', '')

        # Initialize response variables
        recommendation_voiceover_text = ""
        recommendation_music_text = ""
        product_name = product_description 
        person_description = ', '.join(tags)
        print (f'person_description: ', person_description)
        # Leverage LLM OpenAIGPT model to recommend voiceover and music type
        context = build_context_data(product_name, person_description)
        
        if is_recommend_voiceover:
            recommendation_voiceover_text = get_personalized_voiceover_text(context)
        
        if is_recommend_music:
            recommendation_music_text = get_personalized_music_type(context)

        # Trim any extra spaces and format the response
        response = {
            'recommendation_voiceover_text': recommendation_voiceover_text.strip(),
            'recommendation_music_text': recommendation_music_text.strip()
        }
        print (f'response of /recommend: {response}')
        return jsonify(response), 200

    except Exception as e:
        print (f'error in /recommend: {str(e)}')
        return jsonify({'error': str(e)}), 500

api.add_resource(ImageUpload, '/upload')
api.add_resource(GenerateStyleImage, '/generate-style-image')
api.add_resource(CheckImageAvailability, '/check-image-availability')
api.add_resource(GetGeneratedImage, '/generated-images/<string:image_name>')
api.add_resource(CreateVideo, '/create-video')

if __name__ == '__main__':
    app.run(debug=True)
